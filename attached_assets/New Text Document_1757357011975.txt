# Full-Stack Event Pipeline Implementation Guide

## ðŸŽ¯ MISSION
Build a production-ready event processing pipeline: **Webhook â†’ Redis Queue â†’ Firebase Push Notifications** with a Next.js admin dashboard. This must be completed within 1 working day and pass rigorous evaluation criteria.

## ðŸ“‹ CRITICAL SUCCESS FACTORS

### 1. SECURITY & CORRECTNESS (40% of evaluation)
- âœ… **Raw body HMAC verification** - Use original request buffer, not parsed JSON
- âœ… **Timestamp validation** - Reject requests older than 5 minutes
- âœ… **Idempotency** - Prevent duplicate processing for 24 hours using event_id
- âœ… **Rate limiting** - 10 requests per 10 seconds per IP

### 2. QUEUE DESIGN (30% of evaluation)
- âœ… **Redis Streams implementation** with Consumer Groups (preferred over Lists)
- âœ… **Exponential backoff retries** (1s â†’ 4s â†’ 10s)
- âœ… **Dead Letter Queue** after 3 failures
- âœ… **Fast response time** (â‰¤300ms after enqueue)

### 3. CODE QUALITY (20% of evaluation)
- âœ… **TypeScript throughout** with proper types
- âœ… **Modular architecture** with small, focused functions
- âœ… **Comprehensive error handling**
- âœ… **Clean separation of concerns**

### 4. OBSERVABILITY & UX (10% of evaluation)
- âœ… **Structured logging** with proper levels
- âœ… **Metrics endpoint** with counters
- âœ… **Intuitive admin dashboard** with search and replay
- âœ… **Health check endpoint**

## ðŸ—ï¸ IMPLEMENTATION ARCHITECTURE

### Project Structure
```
project-root/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”‚   â”œâ”€â”€ webhook/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ order.created/
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ route.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ health/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ route.ts
â”‚   â”‚   â”‚   â””â”€â”€ metrics/
â”‚   â”‚   â”‚       â””â”€â”€ route.ts
â”‚   â”‚   â””â”€â”€ admin/
â”‚   â”‚       â””â”€â”€ events/
â”‚   â”‚           â””â”€â”€ page.tsx
â”‚   â”œâ”€â”€ lib/
â”‚   â”‚   â”œâ”€â”€ redis.ts
â”‚   â”‚   â”œâ”€â”€ firebase.ts
â”‚   â”‚   â”œâ”€â”€ security.ts
â”‚   â”‚   â”œâ”€â”€ queue.ts
â”‚   â”‚   â””â”€â”€ metrics.ts
â”‚   â”œâ”€â”€ worker/
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â””â”€â”€ types/
â”‚       â””â”€â”€ index.ts
â”œâ”€â”€ tests/
â”œâ”€â”€ .env.example
â”œâ”€â”€ README.md
â”œâ”€â”€ docker-compose.yml
â””â”€â”€ package.json
```

## ðŸ”§ DETAILED IMPLEMENTATION SPECIFICATIONS

### 1. Webhook API Endpoint (`/api/webhook/order.created`)

#### Security Implementation:
```typescript
// Must use raw body for HMAC - critical requirement
const rawBody = await request.text();
const signature = headers.get('x-signature');
const timestamp = headers.get('x-timestamp');

// Verify timestamp (within 5 minutes)
const now = Math.floor(Date.now() / 1000);
if (now - parseInt(timestamp) > 300) {
  return Response.json({ error: 'Request too old' }, { status: 400 });
}

// Verify HMAC signature
const expectedSig = crypto
  .createHmac('sha256', process.env.WEBHOOK_SECRET!)
  .update(rawBody)
  .digest('hex');

if (!crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(expectedSig))) {
  return Response.json({ error: 'Invalid signature' }, { status: 401 });
}
```

#### Idempotency & Rate Limiting:
```typescript
// Redis-based idempotency (24h TTL)
const idempotencyKey = `idempotency:${event_id}`;
const exists = await redis.exists(idempotencyKey);
if (exists) {
  return Response.json({ message: 'Duplicate event ignored' }, { status: 200 });
}
await redis.setex(idempotencyKey, 86400, '1');

// Rate limiting (10 req/10s per IP)
const rateLimitKey = `rate_limit:${clientIP}`;
const current = await redis.incr(rateLimitKey);
if (current === 1) await redis.expire(rateLimitKey, 10);
if (current > 10) {
  return Response.json({ error: 'Rate limit exceeded' }, { status: 429 });
}
```

### 2. Redis Queue Implementation

#### Streams Setup (Preferred):
```typescript
// Add to stream
await redis.xadd(
  'orders-stream',
  '*',
  'event_id', event_id,
  'payload', JSON.stringify(data),
  'timestamp', Date.now(),
  'retry_count', '0'
);

// Consumer group setup
try {
  await redis.xgroup('CREATE', 'orders-stream', 'workers', '$', 'MKSTREAM');
} catch (e) {
  // Group already exists
}
```

### 3. Worker Implementation

#### Consumer Logic with Retries:
```typescript
// Exponential backoff calculation
const calculateDelay = (retryCount: number): number => {
  const delays = [1000, 4000, 10000]; // 1s, 4s, 10s
  return delays[Math.min(retryCount, delays.length - 1)];
};

// Main worker loop
while (true) {
  const messages = await redis.xreadgroup(
    'GROUP', 'workers', 'worker-1',
    'COUNT', 1,
    'BLOCK', 1000,
    'STREAMS', 'orders-stream', '>'
  );
  
  for (const message of messages) {
    try {
      await processEvent(message);
      await redis.xack('orders-stream', 'workers', message.id);
    } catch (error) {
      await handleRetry(message, error);
    }
  }
}
```

#### FCM Integration:
```typescript
// Firebase setup
const admin = require('firebase-admin');
admin.initializeApp({
  credential: admin.credential.cert(serviceAccount),
});

// Send notification
const deviceToken = await redis.get(`fcm:token:${userId}`);
const message = {
  notification: {
    title: 'New Order',
    body: `Order ${order_id} placed by ${userId}`,
  },
  token: deviceToken || undefined,
  topic: deviceToken ? undefined : 'orders',
};

if (process.env.FCM_DRY_RUN === 'true') {
  console.log('DRY RUN:', message);
} else {
  await admin.messaging().send(message);
}
```

### 4. Admin Dashboard (`/admin/events`)

#### Features Required:
- **Event List**: Display last 20 events with status badges
- **Search**: Filter by event_id
- **Replay**: Button to requeue failed events
- **Real-time Updates**: Show current queue status

#### UI Components:
```typescript
// Event status component
const StatusBadge = ({ status }: { status: EventStatus }) => {
  const colors = {
    queued: 'bg-yellow-100 text-yellow-800',
    processing: 'bg-blue-100 text-blue-800',
    sent: 'bg-green-100 text-green-800',
    failed: 'bg-red-100 text-red-800',
  };
  
  return (
    <span className={`px-2 py-1 rounded-full text-xs ${colors[status]}`}>
      {status}
    </span>
  );
};
```

### 5. Health & Metrics Endpoints

```typescript
// GET /api/health
{
  "ok": true,
  "redis": "up",
  "timestamp": "2025-01-15T10:30:00Z",
  "uptime": 3600
}

// GET /api/metrics
{
  "received": 1250,
  "deduped": 15,
  "sent": 1180,
  "failed": 45,
  "dlq": 10,
  "queue_size": 5
}
```

## ðŸ§ª TESTING REQUIREMENTS

### Jest Test Cases:
1. **Signature Verification**
   - Valid HMAC passes
   - Invalid HMAC rejected
   - Missing signature rejected

2. **Timestamp Validation**
   - Recent timestamps accepted
   - Old timestamps rejected
   - Future timestamps handled

3. **Idempotency**
   - Duplicate event_id ignored
   - Different event_ids processed

4. **Retry Logic**
   - Backoff calculation correct
   - Max retries respected
   - DLQ movement after failures

## ðŸ“¦ DELIVERABLES CHECKLIST

### 1. GitHub Repository:
- [ ] README.md with ASCII diagram and setup instructions
- [ ] All API routes implemented and tested
- [ ] Worker script with npm run worker command
- [ ] Next.js admin dashboard fully functional
- [ ] Proper TypeScript types throughout

### 2. API Examples:
- [ ] Postman collection or cURL commands
- [ ] Valid webhook example with signature
- [ ] Duplicate webhook demonstration
- [ ] Replay functionality example

### 3. Environment Setup:
```bash
# .env.example
WEBHOOK_SECRET=your-secret-key
REDIS_URL=redis://localhost:6379
FIREBASE_PROJECT_ID=your-project-id
FIREBASE_PRIVATE_KEY="-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----\n"
FIREBASE_CLIENT_EMAIL=firebase-adminsdk-xyz@your-project.iam.gserviceaccount.com
FCM_DRY_RUN=true
```

## ðŸš€ BONUS IMPLEMENTATIONS (If Time Permits)

1. **Docker Setup**:
```yaml
# docker-compose.yml
version: '3.8'
services:
  app:
    build: .
    ports:
      - "3000:3000"
    depends_on:
      - redis
  
  worker:
    build: .
    command: npm run worker
    depends_on:
      - redis
  
  redis:
    image: redis:alpine
    ports:
      - "6379:6379"
```

2. **GitHub Actions**:
```yaml
# .github/workflows/test.yml
name: Tests
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: npm ci
      - run: npm test
```

## âš¡ PERFORMANCE TARGETS

- **Webhook Response**: â‰¤ 300ms after Redis enqueue
- **Worker Processing**: < 2 seconds per event
- **Dashboard Load**: < 1 second initial render
- **Memory Usage**: < 512MB for entire application

## ðŸ” EVALUATION FOCUS AREAS

The evaluator will specifically look for:
1. **Raw body HMAC implementation** (most common failure point)
2. **Proper timestamp validation logic**
3. **Redis Streams usage over simple lists**
4. **Exponential backoff implementation**
5. **Error handling coverage**
6. **Type safety throughout**
7. **Clear separation between API and worker processes**
8. **Functional replay mechanism in dashboard**

## ðŸ“‹ FINAL IMPLEMENTATION CHECKLIST

Before submission, verify:
- [ ] All webhook security measures implemented correctly
- [ ] Redis queue operations working with proper error handling
- [ ] FCM integration functional (dry-run mode)
- [ ] Admin dashboard shows events and allows replay
- [ ] All tests pass (minimum 80% coverage)
- [ ] README includes complete setup instructions
- [ ] Environment variables properly documented
- [ ] Rate limiting functional
- [ ] Health and metrics endpoints returning correct data
- [ ] Worker can be started independently
- [ ] Docker setup optional but functional if implemented

---

**Remember**: This is a 1-day assignment focused on demonstrating system design, security implementation, and full-stack development skills. Quality over quantity - make sure each component works correctly rather than adding unnecessary features.